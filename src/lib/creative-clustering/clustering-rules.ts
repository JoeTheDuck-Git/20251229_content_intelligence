import { CreativeSignature, CreativeCluster, FatigueStatus } from "@/types/clustering";

function getMostCommon<T>(items: T[]): T {
  const counts: Record<string, number> = {};
  items.forEach((item) => {
    const key = String(item);
    counts[key] = (counts[key] || 0) + 1;
  });

  let maxCount = 0;
  let mostCommon = items[0];
  Object.entries(counts).forEach(([key, count]) => {
    if (count > maxCount) {
      maxCount = count;
      mostCommon = items.find((item) => String(item) === key)!;
    }
  });

  return mostCommon;
}

function generateClusterLabel(
  hookType: string,
  pacing: string,
  duration: string
): string {
  const hookLabel = hookType
    .split("-")
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join(" ");
  const pacingLabel = pacing.charAt(0).toUpperCase() + pacing.slice(1);
  const durationLabel = duration.charAt(0).toUpperCase() + duration.slice(1);

  return `${hookLabel} - ${pacingLabel} Paced - ${durationLabel} Duration`;
}

function assessFatigueRisk(
  fatigueStatuses: FatigueStatus[]
): "low" | "medium" | "high" {
  const fatiguedCount = fatigueStatuses.filter((s) => s === "fatigued").length;
  const warningCount = fatigueStatuses.filter((s) => s === "early_warning").length;
  const total = fatigueStatuses.length;

  if (total === 0) return "low";

  const fatiguedRatio = fatiguedCount / total;
  const warningRatio = warningCount / total;

  if (fatiguedRatio >= 0.5 || (fatiguedRatio >= 0.3 && warningRatio >= 0.3)) {
    return "high";
  }

  if (fatiguedRatio >= 0.2 || warningRatio >= 0.5) {
    return "medium";
  }

  return "low";
}

function assessScaleReliability(
  fatigueStatuses: FatigueStatus[]
): "unstable" | "moderate" | "reliable" {
  const healthyCount = fatigueStatuses.filter((s) => s === "healthy").length;
  const total = fatigueStatuses.length;

  if (total === 0) return "moderate";

  const healthyRatio = healthyCount / total;

  if (healthyRatio >= 0.7) {
    return "reliable";
  }

  if (healthyRatio >= 0.4) {
    return "moderate";
  }

  return "unstable";
}

export function createClusterFromSignatures(
  signatures: CreativeSignature[],
  clusterId: string
): CreativeCluster {
  if (signatures.length === 0) {
    throw new Error("Cannot create cluster from empty signatures");
  }

  // Determine defining features (most common values)
  const hookTypes = signatures.map((s) => s.hookType);
  const pacings = signatures.map((s) => s.pacing);
  const durationBuckets = signatures.map((s) => s.durationBucket);

  const mostCommonHook = getMostCommon(hookTypes);
  const mostCommonPacing = getMostCommon(pacings);
  const mostCommonDuration = getMostCommon(durationBuckets);

  const definingFeatures = [
    mostCommonHook,
    mostCommonPacing,
    mostCommonDuration,
  ];

  // Generate cluster label
  const label = generateClusterLabel(
    mostCommonHook,
    mostCommonPacing,
    mostCommonDuration
  );

  // Analyze fatigue risk
  const fatigueStatuses = signatures.map((s) => s.fatigueStatus);
  const fatigueRiskLevel = assessFatigueRisk(fatigueStatuses);

  // Analyze scale reliability
  const scaleReliability = assessScaleReliability(fatigueStatuses);

  return {
    clusterId,
    label,
    definingFeatures,
    assetIds: signatures.map((s) => s.assetId),
    fatigueRiskLevel,
    scaleReliability,
    explanation: "", // Will be generated by explainer
    usageGuidance: [], // Will be generated by explainer
  };
}

export function clusterSignatures(
  signatures: CreativeSignature[]
): CreativeCluster[] {
  const clusters: CreativeCluster[] = [];
  const processed = new Set<string>();

  signatures.forEach((signature) => {
    if (processed.has(signature.assetId)) {
      return;
    }

    // Find all signatures that match this one
    const matchingSignatures = signatures.filter((sig) => {
      if (processed.has(sig.assetId)) {
        return false;
      }

      // Match if same hook, pacing, and duration bucket
      return (
        sig.hookType === signature.hookType &&
        sig.pacing === signature.pacing &&
        sig.durationBucket === signature.durationBucket
      );
    });

    if (matchingSignatures.length > 0) {
      const clusterId = `cluster-${clusters.length + 1}`;
      const cluster = createClusterFromSignatures(
        matchingSignatures,
        clusterId
      );

      clusters.push(cluster);
      matchingSignatures.forEach((sig) => processed.add(sig.assetId));
    }
  });

  return clusters;
}

